{"version":3,"sources":["lib/block.js","lib/mazeTraversal.js","components/Maze.js","components/CanvasMaze.js","lib/utils.js","lib/mazeGenerator.js","App.js","serviceWorker.js","index.js"],"names":["Walls","defaultWalls","left","right","bottom","top","Block","row","column","walls","_walls","_row","_column","this","Object","keys","find","k","wall","neighbor","breakWall","findPath","maze","from","to","console","time","nodes","map","block","coveredDistance","candidates","visited","path","current","pop","currentBlock","push","node","previous","connectedNeighbors","filter","w","getNeighborFromWall","n","estimatedDistance","getEstimatedDistanceTo","concat","sort","a","b","timeEnd","Math","sqrt","pow","onClick","highlight","start","end","onMouseOver","blockClass","join","className","classnames","Maze","showVisited","useState","setVisited","setPath","setStart","setEnd","clear","useEffect","line","i","key","j","indexOf","result","canvasImage","setCanvasImage","canvasRef","useRef","canvas","getContext","clearRect","width","height","fillBlock","ctx","color","fillStyle","fillRect","forEach","r","origin","x","y","beginPath","moveTo","lineTo","stroke","img","Image","src","toDataURL","drawMaze","drawImage","ref","length","event","rect","getBoundingClientRect","parseInt","clientX","clientY","onMouseMove","getRandomNumber","max","floor","random","getNeighbors","newMaze","size","arr","Array","fill","_","unvisited","next","breakWallWith","App","setMaze","setShowVisited","renderer","setRenderer","sizeInput","value","type","onChange","e","target","checked","name","CanvasMaze","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"4OAAaA,EACH,OADGA,EAEF,QAFEA,EAGJ,MAHIA,EAID,SAGNC,EAAe,CAAEC,MAAM,EAAMC,OAAO,EAAMC,QAAQ,EAAMC,KAAK,GAEtDC,EAAb,WAII,WAAYC,EAAKC,EAAQC,GAAQ,yBAHjCC,OAAS,GAGuB,KAFhCC,KAAO,EAEyB,KADhCC,QAAU,EAENC,KAAKF,KAAOJ,EACZM,KAAKD,QAAUJ,EACfK,KAAKH,OAAL,2BAAmBT,GAAiBQ,GAP5C,uDAsBe,IAAD,OACP,OAAQK,OAAOC,KAAKF,KAAKH,QAAQM,MAAK,SAAAC,GAAC,OAAK,EAAKP,OAAOO,QAvB/D,gCA0BcC,GACNL,KAAKH,OAAOQ,IAAQ,IA3B5B,oCA8BkBC,GACNA,EAASZ,IAAMM,KAAKN,KACpBM,KAAKO,UAAUpB,GACfmB,EAASC,UAAUpB,IACZmB,EAASZ,IAAMM,KAAKN,KAC3BM,KAAKO,UAAUpB,GACfmB,EAASC,UAAUpB,IACZmB,EAASX,OAASK,KAAKL,QAC9BK,KAAKO,UAAUpB,GACfmB,EAASC,UAAUpB,IACZmB,EAASX,OAASK,KAAKL,SAC9BK,KAAKO,UAAUpB,GACfmB,EAASC,UAAUpB,MA1C/B,0BAWQ,OAAOa,KAAKF,OAXpB,6BAeQ,OAAOE,KAAKD,UAfpB,4BAmBQ,OAAO,eAAKC,KAAKH,YAnBzB,KCGaW,EAAW,SAACC,EAAMC,EAAMC,GACjCC,QAAQC,KAAK,YAKb,IAJA,IAAMC,EAAQL,EAAKM,KAAI,SAAArB,GAAG,OAAIA,EAAIqB,KAAI,SAAAC,GAAK,MAAK,CAAEA,QAAOC,gBAAiB,SACtEC,EAAa,CAACJ,EAAMJ,EAAKhB,KAAKgB,EAAKf,SACjCwB,EAAU,GACVC,EAAO,GAL2B,aAOpC,IAAMC,EAAUH,EAAWI,MAC3B,IAAKD,EACD,cAEJ,IAAME,EAAeF,EAAQL,MAI7B,GAHAK,EAAQF,SAAU,EAClBA,EAAQK,KAAKD,GAETA,EAAa7B,MAAQiB,EAAGjB,KAAO6B,EAAa5B,SAAWgB,EAAGhB,OAAQ,CAClE,IAAI8B,EAAOJ,EACX,GACID,EAAKI,KAAKC,EAAKT,OACfS,EAAOA,EAAKC,eACPD,GACT,cAGJ,IAAME,EAAqB1B,OAAOC,KAAKqB,EAAa3B,OAC/CgC,QAAO,SAAAxB,GAAC,OAA8B,IAA1BmB,EAAa3B,MAAMQ,MAC/BW,KAAI,SAAAc,GAAC,OAAIC,EAAoBD,EAAGf,EAAOS,EAAa7B,IAAK6B,EAAa5B,WACtEiC,QAAO,SAAAG,GAAC,OAAKA,EAAEZ,WACfJ,KAAI,SAAAgB,GAID,OAHAA,EAAEd,gBAAkBI,EAAQJ,gBAAkB,EAC9Cc,EAAEC,kBAAoBC,EAAuBF,EAAEf,MAAOL,GACtDoB,EAAEL,SAAWL,EACNU,KAIfb,EAAaA,EAAWgB,OAAOP,GAC1BQ,MAAK,SAACC,EAAGC,GAAJ,OAAWD,EAAEnB,gBAAkBmB,EAAEJ,kBAAsBK,EAAEpB,gBAAkBoB,EAAEL,mBAC5E,EAAMI,EAAEnB,gBAAkBmB,EAAEJ,kBAAsBK,EAAEpB,gBAAkBoB,EAAEL,kBACrE,EAAI,QAjCT,kBAeL,MAqBR,OADApB,QAAQ0B,QAAQ,YACT,CAAEnB,UAASC,SAGTa,EAAyB,SAACG,EAAGC,GAAJ,OAAUE,KAAKC,KAAKD,KAAKE,IAAIJ,EAAE3C,IAAM0C,EAAE1C,IAAK,GAAK6C,KAAKE,IAAIJ,EAAE1C,OAASyC,EAAEzC,OAAQ,KAExGmC,EAAsB,SAACzB,EAAMI,EAAMf,EAAKC,GACjD,OAAQU,GACJ,KAAKlB,EACD,OAAOsB,EAAKf,EAAM,GAAGC,GACzB,KAAKR,EACD,OAAOsB,EAAKf,EAAM,GAAGC,GACzB,KAAKR,EACD,OAAOsB,EAAKf,GAAKC,EAAS,GAC9B,QACI,OAAOc,EAAKf,GAAKC,EAAS,K,gBCbhCF,EAAQ,SAAC,GAAkE,IAAhEuB,EAA+D,EAA/DA,MAAO0B,EAAwD,EAAxDA,QAASC,EAA+C,EAA/CA,UAAWvB,EAAoC,EAApCA,KAAMwB,EAA8B,EAA9BA,MAAOC,EAAuB,EAAvBA,IAAKC,EAAkB,EAAlBA,YACpDC,EAAa9C,OAAOC,KAAKc,EAAMpB,OAAOgC,QAAO,SAAAxB,GAAC,OAAIY,EAAMpB,MAAMQ,MAAI4C,KAAK,KAC7E,OACI,yBAAKC,UAAS,gBAAWC,IAAW,CAAEP,YAAWvB,OAAMwB,QAAOC,SAC1DH,QAASA,EAASI,YAAaA,GAC/B,yBAAKG,UAAWF,MAKbI,EA7DF,SAAC,GAA2B,IAAzB1C,EAAwB,EAAxBA,KAAM2C,EAAkB,EAAlBA,YAAkB,EACNC,mBAAS,IADH,mBAC7BlC,EAD6B,KACpBmC,EADoB,OAEZD,mBAAS,IAFG,mBAE7BjC,EAF6B,KAEvBmC,EAFuB,OAIVF,mBAAS,MAJC,mBAI7BT,EAJ6B,KAItBY,EAJsB,OAKdH,mBAAS,MALK,mBAK7BR,EAL6B,KAKxBY,EALwB,KAO9BC,EAAQ,WACVF,EAAS,MACTC,EAAO,MACPH,EAAW,IACXC,EAAQ,KAqCZ,OAlCAI,qBAAU,WACND,MACD,CAACjD,IAIA,yBAAKwC,UAAU,QACVxC,GAAQA,EAAKM,KAAI,SAAC6C,EAAMC,GAAP,OAAa,yBAAKC,IAAG,eAAUD,GAAKZ,UAAU,OAC3DW,EAAK7C,KAAI,SAACC,EAAO+C,GAAR,OACN,kBAAC,EAAD,CAAO/C,MAAOA,EAAO8C,IAAG,gBAAWD,EAAX,YAAgBE,GACpCpB,UAAWS,GAAejC,EAAQ6C,QAAQhD,IAAU,EACpDI,KAAMA,EAAK4C,QAAQhD,IAAU,EAC7B4B,MAAOA,GAAS5B,EAAMtB,MAAQkD,EAAMlD,KAAOsB,EAAMrB,SAAWiD,EAAMjD,OAClEkD,IAAKA,GAAO7B,EAAMtB,MAAQmD,EAAInD,KAAOsB,EAAMrB,SAAWkD,EAAIlD,OAC1D+C,QAAS,WACLgB,IACAF,EAAS,CAAE9D,IAAKmE,EAAGlE,OAAQoE,KAG/BjB,YAAa,WACT,GAAIF,GAASA,EAAMlD,MAAQmE,GAAKjB,EAAMjD,SAAWoE,EAAG,CAChDN,EAAO,CAAE/D,IAAKmE,EAAGlE,OAAQoE,IACzB,IAAME,EAASzD,EAASC,EAAMmC,EAAO,CAAElD,IAAKmE,EAAGlE,OAAQoE,IACvDT,EAAWW,EAAO9C,SAClBoC,EAAQU,EAAO7C,mBCoFhC+B,EA1HF,SAAC,GAA2B,IAAzB1C,EAAwB,EAAxBA,KAAM2C,EAAkB,EAAlBA,YAAkB,EACNC,mBAAS,IADH,mBAC7BlC,EAD6B,KACpBmC,EADoB,OAEZD,mBAAS,IAFG,mBAE7BjC,EAF6B,KAEvBmC,EAFuB,OAIVF,mBAAS,MAJC,mBAI7BT,EAJ6B,KAItBY,EAJsB,OAKdH,mBAAS,MALK,mBAK7BR,EAL6B,KAKxBY,EALwB,OAOEJ,mBAAS,MAPX,mBAO7Ba,EAP6B,KAOhBC,EAPgB,KAS9BC,EAAYC,iBAAO,MAEnBX,EAAQ,WACVF,EAAS,MACTC,EAAO,MACPH,EAAW,IACXC,EAAQ,IACR,IAAMe,EAASF,EAAU/C,QACbiD,EAAOC,WAAW,MAC1BC,UAAU,EAAG,EAAGF,EAAOG,MAAOH,EAAOI,SAKvCC,EAAY,SAACC,EAAKC,EAAO7D,GAC3B4D,EAAIE,UAAYD,EAChBD,EAAIG,SAJK,GAII/D,EAAMrB,OAJV,GAIyBqB,EAAMtB,IAJ/B,QAsCbiE,qBAAU,WACND,IAhCa,WACb,IAAMY,EAASF,EAAU/C,QACnBuD,EAAMN,EAAOC,WAAW,MAC9B9D,EAAKuE,SAAQ,SAAAC,GACTA,EAAED,SAAQ,SAAAjD,GACN,IAAMmD,EAAS,CAAEC,EAZhB,GAYmBpD,EAAEpC,OAAeyF,EAZpC,GAYuCrD,EAAErC,KAC1CkF,EAAIS,YACAtD,EAAEnC,MAAMT,KACRyF,EAAIU,OAAOJ,EAAOC,EAAGD,EAAOE,GAC5BR,EAAIW,OAAOL,EAAOC,EAAGD,EAAOE,EAhB/B,KAkBGrD,EAAEnC,MAAMT,KACRyF,EAAIU,OAAOJ,EAAOC,EAnBrB,GAmB+BD,EAAOE,GACnCR,EAAIW,OAAOL,EAAOC,EApBrB,GAoB+BD,EAAOE,EApBtC,KAsBGrD,EAAEnC,MAAMT,KACRyF,EAAIU,OAAOJ,EAAOC,EAAGD,EAAOE,GAC5BR,EAAIW,OAAOL,EAAOC,EAxBrB,GAwB+BD,EAAOE,IAEnCrD,EAAEnC,MAAMT,KACRyF,EAAIU,OAAOJ,EAAOC,EAAGD,EAAOE,EA3B/B,IA4BGR,EAAIW,OAAOL,EAAOC,EA5BrB,GA4B+BD,EAAOE,EA5BtC,KA8BDR,EAAIY,eAGZ,IAAMC,EAAM,IAAIC,MAChBD,EAAIE,IAAMrB,EAAOsB,UAAU,aAC3BzB,EAAesB,GAKfI,KACD,CAACpF,IAEJkD,qBAAU,WACN/C,QAAQC,KAAK,aACb,IAAMyD,EAASF,EAAU/C,QACnBuD,EAAMN,EAAOC,WAAW,MAC9BK,EAAIJ,UAAU,EAAG,EAAGF,EAAOG,MAAOH,EAAOI,QACrC7B,GACA8B,EAAUC,EAAK,MAAO/B,GAE1BO,GAAejC,EAAQ6D,SAAQ,SAAAjD,GAC3B4C,EAAUC,EAAK,eAAgB7C,MAEnCX,EAAK4D,SAAQ,SAAAjD,GACT4C,EAAUC,EAAK,OAAQ7C,MAEvBa,GACA+B,EAAUC,EAAK,QAAShC,GACxBC,GACA8B,EAAUC,EAAK,MAAO/B,GAEtBqB,GACAU,EAAIkB,UAAU5B,EAAa,EAAG,GAGlCtD,QAAQ0B,QAAQ,eAEjB,CAACM,EAAOC,EAAKzB,EAAMgC,IAuBtB,OACI,6BACI,4BAAQ2C,IAAK3B,EAAWnB,UAAU,OAC9BwB,MA9FC,GA8FMhE,EAAKuF,OAAetB,OA9F1B,GA8FkCjE,EAAKuF,OACxCtD,QAzBa,SAACuD,GACtB,IACMC,EADS9B,EAAU/C,QACL8E,wBACdxG,EAASyG,UAAUH,EAAMI,QAAUH,EAAKf,GAAK,IAC7CzF,EAAM0G,UAAUH,EAAMK,QAAUJ,EAAKd,GAAK,IAChD1B,IACAF,EAAS,CAAE9D,MAAKC,YAoBR4G,YAjBW,SAACN,GACpB,IACMC,EADS9B,EAAU/C,QACL8E,wBACdxG,EAASyG,UAAUH,EAAMI,QAAUH,EAAKf,GAAK,IAC7CzF,EAAM0G,UAAUH,EAAMK,QAAUJ,EAAKd,GAAK,IAChD,GAAIxC,GAASA,EAAMlD,MAAQA,GAAOkD,EAAMjD,SAAWA,EAAQ,CACvD8D,EAAO,CAAE/D,MAAKC,WACd,IAAMsE,EAASzD,EAASC,EAAMmC,EAAO,CAAElD,MAAKC,WAC5C2D,EAAWW,EAAO9C,SAClBoC,EAAQU,EAAO7C,YCjHdoF,EAAkB,SAACC,GAAD,OAASlE,KAAKmE,MAAMnE,KAAKoE,SAAWF,IAStDG,EAAe,SAAC/C,EAAGE,EAAGtD,GAQ/B,MAPkB,CACd,CAAEf,IAAKmE,EAAI,EAAGlE,OAAQoE,GACtB,CAAErE,IAAKmE,EAAGlE,OAAQoE,EAAI,GACtB,CAAErE,IAAKmE,EAAGlE,OAAQoE,EAAI,GACtB,CAAErE,IAAKmE,EAAI,EAAGlE,OAAQoE,IAGTnC,QAAO,gBAAGlC,EAAH,EAAGA,IAAKC,EAAR,EAAQA,OAAR,OACpBD,GAAO,GAAKA,EAAMe,EAAKuF,QAAUrG,GAAU,GAAKA,EAASc,EAAKuF,UAC7DjF,KAAI,gBAAGrB,EAAH,EAAGA,IAAKC,EAAR,EAAQA,OAAR,OAAqBc,EAAKf,GAAKC,MACnCiC,QAAO,SAAAuD,GAAC,OAAIA,MCjBR0B,EAAU,SAACC,GACpBlG,QAAQC,KAAK,mBAIb,IAHA,IDH0BkG,ECGpBtG,EAAO,IAAIuG,MAAMF,GAAMG,KAAK,GAC7BlG,KAAI,SAACmG,EAAGrD,GAAJ,OAAU,IAAImD,MAAMF,GAAMG,KAAK,GAAGlG,KAAI,SAACmG,EAAGnD,GAAJ,MAAW,CAAE/C,MAAO,IAAIvB,EAAMoE,EAAGE,GAAI5C,SAAS,SACzFD,EAAa,CAACT,EAAK+F,EAAgB/F,EAAKuF,SAASQ,EAAgB/F,EAAKuF,YACvE,CACC,IAAI3E,EAAUH,EAAWI,MACzB,IAAKD,EACD,MAEJA,EAAQF,SAAU,EAClB,IAAMI,EAAeF,EAAQL,MAEvBmG,EADUP,EAAarF,EAAa7B,IAAK6B,EAAa5B,OAAQc,GACxCmB,QAAO,SAAAG,GAAC,OAAKA,EAAEZ,WACvCiG,EDdW,KADOL,ECeGI,GDdrBnB,OACG,KAEJe,EADOxE,KAAKmE,MAAMnE,KAAKoE,SAAWI,EAAIf,SCarCoB,IACAlG,EAAWM,KAAKH,GAChBH,EAAWM,KAAK4F,GAChB/F,EAAQL,MAAMqG,cAAcD,EAAKpG,QAKzC,OAFAJ,QAAQ0B,QAAQ,mBAET7B,EAAKM,KAAI,SAAArB,GAAG,OAAIA,EAAIqB,KAAI,SAAAU,GAAI,OAAIA,EAAKT,aC4BjCsG,MAhDf,WAAgB,IAAD,EACWjE,mBAAS,MADpB,mBACN5C,EADM,KACA8G,EADA,OAEyBlE,oBAAS,GAFlC,mBAEND,EAFM,KAEOoE,EAFP,OAGmBnE,mBAAS,UAH5B,mBAGNoE,EAHM,KAGIC,EAHJ,KAKPC,EAAYtD,mBAIlB,OAHAV,qBAAU,WACR4D,EAAQV,EAAQ,OACf,IAED,yBAAK5D,UAAU,OAEb,yBAAKA,UAAU,eAAf,cACa,2BAAO8C,IAAK4B,IACvB,4BAAQjF,QAAS,WACX0D,SAASuB,EAAUtG,QAAQuG,QAAUxB,SAASuB,EAAUtG,QAAQuG,QAAU,KAC5EL,EAAQV,EAAQT,SAASuB,EAAUtG,QAAQuG,WAF/C,aAKF,yBAAK3E,UAAU,eACb,+CAA2B,2BAAO4E,KAAK,WAAWC,SAAU,SAAAC,GAAC,OAAIP,EAAeO,EAAEC,OAAOC,aAG3F,yBAAKhF,UAAU,eACb,+CACA,2BAAO4E,KAAK,QAAQK,KAAK,WACvBD,QAAsB,WAAbR,EACTK,SAAU,SAAAC,GAAC,OAAIL,EAAY,aAC7B,yCAEA,2BAAOG,KAAK,QAAQK,KAAK,WACvBD,QAAsB,QAAbR,EACTK,SAAU,SAAAC,GAAC,OAAIL,EAAY,UAC7B,uCAIAjH,EACe,QAAbgH,EACI,kBAAC,EAAD,CAAMhH,KAAMA,EAAM2C,YAAaA,IAC/B,kBAAC+E,EAAD,CAAY1H,KAAMA,EAAM2C,YAAaA,IACvC,OCnCQgF,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACL,kBAAC,EAAD,MAEFC,SAASC,eAAe,SD0HpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLxI,QAAQwI,MAAMA,EAAMC,a","file":"static/js/main.f550b0af.chunk.js","sourcesContent":["export const Walls = {\n    LEFT: 'left',\n    RIGHT: 'right',\n    TOP: 'top',\n    BOTTOM: 'bottom'\n}\n\nconst defaultWalls = { left: true, right: true, bottom: true, top: true };\n\nexport class Block {\n    _walls = {};\n    _row = 0;\n    _column = 0;\n    constructor(row, column, walls) {\n        this._row = row;\n        this._column = column;\n        this._walls = { ...defaultWalls, ...walls }\n    }\n\n    get row() {\n        return this._row;\n    }\n\n    get column() {\n        return this._column;\n    }\n\n    get walls() {\n        return { ...this._walls };\n    }\n\n    isClosed(){\n       return !Object.keys(this._walls).find(k => !this._walls[k]);\n    }\n\n    breakWall(wall) {\n        this._walls[wall] = false;\n    }\n\n    breakWallWith(neighbor) {\n        if (neighbor.row < this.row) {\n            this.breakWall(Walls.TOP);\n            neighbor.breakWall(Walls.BOTTOM);\n        } else if (neighbor.row > this.row) {\n            this.breakWall(Walls.BOTTOM);\n            neighbor.breakWall(Walls.TOP);\n        } else if (neighbor.column < this.column) {\n            this.breakWall(Walls.LEFT);\n            neighbor.breakWall(Walls.RIGHT);\n        } else if (neighbor.column > this.column) {\n            this.breakWall(Walls.RIGHT);\n            neighbor.breakWall(Walls.LEFT);\n        }\n    }\n}\n","import { Walls } from \"./block\";\n\nexport const clearMaze = (maze) => {\n    for (let row = 0; row < maze.length; row++) {\n        for (let column = 0; column < maze.length; column++) {\n            if (maze[row][column])\n                maze[row][column].highlight = false;\n        }\n    }\n    return maze;\n}\n\nexport const findPath = (maze, from, to) => {\n    console.time(\"findPath\");\n    const nodes = maze.map(row => row.map(block => ({ block, coveredDistance: 0 })));\n    let candidates = [nodes[from.row][from.column]];\n    const visited = [];\n    const path = [];\n    while (true) {\n        const current = candidates.pop();\n        if (!current)\n            break;\n\n        const currentBlock = current.block;\n        current.visited = true;\n        visited.push(currentBlock);\n\n        if (currentBlock.row === to.row && currentBlock.column === to.column) {\n            let node = current;\n            do {\n                path.push(node.block);\n                node = node.previous;\n            } while (node)\n            break;\n        }\n\n        const connectedNeighbors = Object.keys(currentBlock.walls)\n            .filter(k => currentBlock.walls[k] === false)\n            .map(w => getNeighborFromWall(w, nodes, currentBlock.row, currentBlock.column))\n            .filter(n => !n.visited)\n            .map(n => {\n                n.coveredDistance = current.coveredDistance + 1;\n                n.estimatedDistance = getEstimatedDistanceTo(n.block, to);\n                n.previous = current;\n                return n\n            })\n\n\n        candidates = candidates.concat(connectedNeighbors)\n            .sort((a, b) => (a.coveredDistance + a.estimatedDistance) > (b.coveredDistance + b.estimatedDistance)\n                ? -1 : ((a.coveredDistance + a.estimatedDistance) < (b.coveredDistance + b.estimatedDistance)\n                    ? 1 : 0));\n    }\n    console.timeEnd(\"findPath\");\n    return { visited, path };\n}\n\nexport const getEstimatedDistanceTo = (a, b) => Math.sqrt(Math.pow(b.row - a.row, 2) + Math.pow(b.column - a.column, 2));\n\nexport const getNeighborFromWall = (wall, maze, row, column) => {\n    switch (wall) {\n        case Walls.TOP:\n            return maze[row - 1][column];\n        case Walls.BOTTOM:\n            return maze[row + 1][column];\n        case Walls.LEFT:\n            return maze[row][column - 1];\n        default:\n            return maze[row][column + 1];\n    }\n}\n","import React, { useEffect, useState } from 'react';\nimport { findPath } from '../lib/mazeTraversal';\nimport classnames from 'classnames';\n\nconst Maze = ({ maze, showVisited }) => {\n    const [visited, setVisited] = useState([]);\n    const [path, setPath] = useState([]);\n\n    const [start, setStart] = useState(null);\n    const [end, setEnd] = useState(null);\n\n    const clear = () => {\n        setStart(null);\n        setEnd(null);\n        setVisited([]);\n        setPath([]);\n    }\n\n    useEffect(() => {\n        clear();\n    }, [maze])\n\n    // console.time(\"Render\");\n    const mazeDom = (\n        <div className=\"maze\">\n            {maze && maze.map((line, i) => <div key={`line-${i}`} className=\"row\">\n                {line.map((block, j) =>\n                    <Block block={block} key={`block-${i}-${j}`}\n                        highlight={showVisited && visited.indexOf(block) >= 0}\n                        path={path.indexOf(block) >= 0}\n                        start={start && block.row === start.row && block.column === start.column}\n                        end={end && block.row === end.row && block.column === end.column}\n                        onClick={() => {\n                            clear();\n                            setStart({ row: i, column: j });\n                        }}\n\n                        onMouseOver={() => {\n                            if (start && start.row !== i && start.column !== j) {\n                                setEnd({ row: i, column: j });\n                                const result = findPath(maze, start, { row: i, column: j });\n                                setVisited(result.visited);\n                                setPath(result.path);\n                            }\n                        }} />\n                )}\n            </div>)\n            }\n        </div>\n    )\n\n    // console.timeEnd(\"Render\");\n    return mazeDom;\n}\n\nconst Block = ({ block, onClick, highlight, path, start, end, onMouseOver }) => {\n    const blockClass = Object.keys(block.walls).filter(k => block.walls[k]).join(\" \");\n    return (\n        <div className={`block ${classnames({ highlight, path, start, end })}`}\n            onClick={onClick} onMouseOver={onMouseOver} >\n            <div className={blockClass} />\n        </div>\n    )\n}\n\nexport default Maze;","import React, { useEffect, useRef, useState } from 'react';\nimport { findPath } from '../lib/mazeTraversal';\nimport { Walls } from '../lib/block';\n\nconst Maze = ({ maze, showVisited }) => {\n    const [visited, setVisited] = useState([]);\n    const [path, setPath] = useState([]);\n\n    const [start, setStart] = useState(null);\n    const [end, setEnd] = useState(null);\n\n    const [canvasImage, setCanvasImage] = useState(null);\n\n    const canvasRef = useRef(null)\n\n    const clear = () => {\n        setStart(null);\n        setEnd(null);\n        setVisited([]);\n        setPath([]);\n        const canvas = canvasRef.current\n        const ctx = canvas.getContext('2d')\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n    }\n\n    const size = 20;\n\n    const fillBlock = (ctx, color, block) => {\n        ctx.fillStyle = color;\n        ctx.fillRect(block.column * size, block.row * size, size, size)\n    }\n\n    const drawMaze = () => {\n        const canvas = canvasRef.current\n        const ctx = canvas.getContext('2d')\n        maze.forEach(r => {\n            r.forEach(n => {\n                const origin = { x: n.column * size, y: n.row * size }\n                ctx.beginPath();\n                if (n.walls[Walls.LEFT]) {\n                    ctx.moveTo(origin.x, origin.y);\n                    ctx.lineTo(origin.x, origin.y + size);\n                }\n                if (n.walls[Walls.RIGHT]) {\n                    ctx.moveTo(origin.x + size, origin.y);\n                    ctx.lineTo(origin.x + size, origin.y + size);\n                }\n                if (n.walls[Walls.TOP]) {\n                    ctx.moveTo(origin.x, origin.y);\n                    ctx.lineTo(origin.x + size, origin.y);\n                }\n                if (n.walls[Walls.BOTTOM]) {\n                    ctx.moveTo(origin.x, origin.y + size);\n                    ctx.lineTo(origin.x + size, origin.y + size);\n                }\n                ctx.stroke();\n            })\n        });\n        const img = new Image();\n        img.src = canvas.toDataURL(\"image/png\");\n        setCanvasImage(img);\n    }\n\n    useEffect(() => {\n        clear();\n        drawMaze();\n    }, [maze])\n\n    useEffect(() => {\n        console.time(\"rendering\")\n        const canvas = canvasRef.current\n        const ctx = canvas.getContext('2d')\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        if (end)\n            fillBlock(ctx, 'red', end);\n\n        showVisited && visited.forEach(n => {\n            fillBlock(ctx, 'lightskyblue', n);\n        })\n        path.forEach(n => {\n            fillBlock(ctx, 'pink', n);\n        })\n        if (start)\n            fillBlock(ctx, 'green', start);\n        if (end)\n            fillBlock(ctx, 'red', end);\n\n        if (canvasImage) {\n            ctx.drawImage(canvasImage, 0, 0)\n        }\n        // drawMaze();\n        console.timeEnd(\"rendering\")\n\n    }, [start, end, path, showVisited])\n\n    const setStartPosition = (event) => {\n        const canvas = canvasRef.current;\n        const rect = canvas.getBoundingClientRect();\n        const column = parseInt((event.clientX - rect.x) / 20);\n        const row = parseInt((event.clientY - rect.y) / 20);\n        clear();\n        setStart({ row, column });\n    }\n\n    const setEndPosition = (event) => {\n        const canvas = canvasRef.current;\n        const rect = canvas.getBoundingClientRect();\n        const column = parseInt((event.clientX - rect.x) / 20);\n        const row = parseInt((event.clientY - rect.y) / 20);\n        if (start && start.row !== row && start.column !== column) {\n            setEnd({ row, column });\n            const result = findPath(maze, start, { row, column });\n            setVisited(result.visited);\n            setPath(result.path);\n        }\n    }\n    return (\n        <div>\n            <canvas ref={canvasRef} className=\"maze\"\n                width={maze.length * size} height={maze.length * size}\n                onClick={setStartPosition}\n                onMouseMove={setEndPosition} />\n        </div>\n    )\n}\n\nexport default Maze;","export const getRandomNumber = (max) => Math.floor(Math.random() * max);\n\nexport const pickOneRandom = (arr) => {\n    if (arr.length === 0)\n        return null;\n    const index = Math.floor(Math.random() * arr.length);\n    return arr[index];\n}\n\nexport const getNeighbors = (i, j, maze) => {\n    const neighbors = [\n        { row: i - 1, column: j },\n        { row: i, column: j - 1 },\n        { row: i, column: j + 1 },\n        { row: i + 1, column: j },\n    ];\n\n    return neighbors.filter(({ row, column }) =>\n        row >= 0 && row < maze.length && column >= 0 && column < maze.length)\n        .map(({ row, column }) => maze[row][column])\n        .filter(x => x);\n}","import { Block } from \"./block\"\nimport { getNeighbors, pickOneRandom, getRandomNumber } from './utils';\n\nexport const newMaze = (size) => {\n    console.time(\"maze generation\")\n    const maze = new Array(size).fill(0)\n        .map((_, i) => new Array(size).fill(0).map((_, j) => ({ block: new Block(i, j), visited: false })));\n    let candidates = [maze[getRandomNumber(maze.length)][getRandomNumber(maze.length)]];\n    do {\n        let current = candidates.pop();\n        if (!current)\n            break;\n\n        current.visited = true;\n        const currentBlock = current.block;\n        let neighbors = getNeighbors(currentBlock.row, currentBlock.column, maze);\n        const unvisited = neighbors.filter(n => !n.visited);\n        let next = pickOneRandom(unvisited);\n        if (next) {\n            candidates.push(current);\n            candidates.push(next);\n            current.block.breakWallWith(next.block);\n        }\n    } while (true)\n    console.timeEnd(\"maze generation\")\n\n    return maze.map(row => row.map(node => node.block));\n}\n","import React, { useEffect, useRef, useState } from 'react';\nimport './App.css';\nimport Maze from './components/Maze';\nimport CanvasMaze from './components/CanvasMaze';\nimport { newMaze } from './lib/mazeGenerator';\n\nfunction App() {\n  const [maze, setMaze] = useState(null);\n  const [showVisited, setShowVisited] = useState(false);\n  const [renderer, setRenderer] = useState('canvas');\n\n  const sizeInput = useRef();\n  useEffect(() => {\n    setMaze(newMaze(20));\n  }, [])\n  return (\n    <div className=\"App\">\n\n      <div className=\"input-group\">\n        Maze Size: <input ref={sizeInput} />\n        <button onClick={() => {\n          if (parseInt(sizeInput.current.value) && parseInt(sizeInput.current.value) <= 1000)\n            setMaze(newMaze(parseInt(sizeInput.current.value)))\n        }}>Generate</button>\n      </div>\n      <div className=\"input-group\">\n        <label>Show visited</label><input type=\"checkbox\" onChange={e => setShowVisited(e.target.checked)} />\n      </div>\n\n      <div className=\"input-group\">\n        <span>Render method</span>\n        <input type=\"radio\" name=\"renderer\"\n          checked={renderer === 'canvas'}\n          onChange={e => setRenderer('canvas')} />\n        <label>Canvas</label>\n\n        <input type=\"radio\" name=\"renderer\"\n          checked={renderer === 'dom'}\n          onChange={e => setRenderer('dom')} />\n        <label>DOM</label>\n      </div>\n\n      {\n        maze ?\n          renderer === 'dom'\n            ? <Maze maze={maze} showVisited={showVisited} />\n            : <CanvasMaze maze={maze} showVisited={showVisited} />\n          : null\n      }\n\n    </div >\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n    <App />\n  ,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}